/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect, useMemo} from 'react'
import { useGLTF, useScroll, ScrollControls, Scroll, PivotControls } from '@react-three/drei'
import { type GLTF } from 'three-stdlib'
import model from '/models/sku/cap_bottle.glb?url'
import { useFrame, useThree } from '@react-three/fiber'
import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

type GLTFResult = GLTF & {
  nodes: {
    model: THREE.Mesh
  }
  materials: {
    material_0: THREE.MeshPhysicalMaterial
  }
}
function PointCloudMesh({ ...props }) {
  const scroll = useScroll()
  const { nodes, materials } = useGLTF(model) as GLTFResult
  const state = useRef<THREE.Mesh>(null)
  
  const ref = useRef()
  const lastScroll = useRef(scroll.offset);
  
  const sphereGeometry = new THREE.SphereGeometry(0.002, 6, 6);
  const sphereMaterial = new THREE.MeshBasicMaterial({
  color: 0xffa0e6
  });
  const TOTAL_POINTS = 300;

  const mesh = new THREE.Mesh(nodes.model.geometry)
  const sampler = new MeshSurfaceSampler(mesh).build();

  const pc_mesh = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, TOTAL_POINTS);
  // pc_mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage )
  pc_mesh.position.set(mesh.position.x, mesh.position.y, mesh.position.z)
  pc_mesh.rotation.set(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z)

  const raycaster = useMemo(() => new THREE.Raycaster(), []);
  const from = new THREE.Vector3(0, 2.4, 0);
  raycaster.near = 0.2;
  raycaster.far = 10;
  const camera = useThree((state) => state.camera)

  useEffect(() => {
    raycaster.camera = camera;
  },[raycaster, camera])
  useFrame((state, delta) => {
    if (scroll.offset !== lastScroll.current) {
      lastScroll.current = scroll.offset;
      // Place your logic here that should run only when scroll changes
      console.log('Scroll changed:', scroll.offset);
      const COUNT = Math.floor(scroll.offset * TOTAL_POINTS);
      const tempObject = new THREE.Object3D();
      const tempPosition = new THREE.Vector3();
      ref.current.position.set(mesh.position.x, mesh.position.y, mesh.position.z)
      ref.current.rotation.set(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z)

      for (let i = 0; i < TOTAL_POINTS; i++) {
        if (i > COUNT) {
          continue;
        }

        tempObject.position.set(0, 0, 0);
        sampler.sample(tempPosition);

        tempObject.position.set(tempPosition.x, tempPosition.y, tempPosition.z);
        // tempObject.scale.setScalar(Math.random() * 0.5 + 0.5);;
        tempObject.updateMatrix();
        tempObject.updateMatrixWorld();

        // const tempWorldPosition = new THREE.Vector3();
        // const tempWorldPosition = tempObject.localToWorld(tempObject.position);
        // const meshWorldPosition = new THREE.Vector3();
        // const meshWorldQuaternion = new THREE.Quaternion();
        // // tempObject.localToWorld(meshWorldPosition);
        // mesh.getWorldQuaternion(meshWorldQuaternion);

        // If the points are on the surface
        // tempWorldPosition.add(meshWorldPosition);
        // console.log(tempWorldPosition)
        // tempWorldPosition.applyQuaternion(meshWorldQuaternion);

        // console.log(tempWorldPosition);

        // If the points are not on the surface
        // Use raycaster.
        // const direction = from.clone().sub(tempWorldPosition).normalize();
        // const geometry = new THREE.BufferGeometry();
        // const positions = [
        //   from.x, from.y, from.z,
        //   tempWorldPosition.x, tempWorldPosition.y, tempWorldPosition.z
        // ];
        // geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        // const colors = [
        //   Math.random(), Math.random(), Math.random(),
        //   Math.random(), Math.random(), Math.random()
        // ];
        // geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        // const material = new THREE.LineBasicMaterial( { vertexColors: true } );
        // const line = new THREE.Line(geometry, material);

        // // state.scene.add(line)

        // raycaster.set(from, direction);
        // const intersects = raycaster.intersectObjects(state.scene.children);
        // if (intersects.length > 0 && intersects[0].distance < 1) {
        //   console.log(intersects)
        //   continue;
        // }

        ref.current.setMatrixAt(i, tempObject.matrix);
        ref.current.setColorAt(i, new THREE.Color(Math.random(), Math.random(), Math.random()));
        ref.current.instanceMatrix.needsUpdate = true;
        ref.current.instanceColor.needsUpdate = true;
      }	
    }

    
  })
  return <primitive ref={ref} object={pc_mesh} {...props} dispose={null} />;
}

function PhysicalMesh({ ...props }) { 
  const scroll = useScroll()
  const ref = useRef()
  const { nodes, materials } = useGLTF(model) as GLTFResult
  const mesh = new THREE.Mesh(
    nodes.model.geometry,
    materials.material_0,
  )
  useFrame((state, delta) => {
    if (ref.current) {
      ref.current.material.opacity = 1 - scroll.offset / 1.5;
      ref.current.material.transparent = true;
      ref.current.material.needsUpdate = true;
    }
  });
  return <primitive ref={ref} object={mesh} {...props} dispose={null} />;
}
function BBoxMesh({ ...props }) { 
  const { nodes, materials } = useGLTF(model) as GLTFResult
  const mesh = useMemo(() => new THREE.Mesh(
    nodes.model.geometry,
    materials.material_0,
  ), [nodes, materials]);
  const boxHelperRef = useRef<THREE.BoxHelper>(null);

  useFrame(() => {
    if (boxHelperRef.current) {
      boxHelperRef.current.update();
    }
  });

  return (
    <>
      <primitive ref={boxHelperRef} object={new THREE.BoxHelper(mesh, 0xffff00)} {...props} />
    </>
  );
}


export function CapBottle(props: JSX.IntrinsicElements['group']) {
  

  return (
    <group {...props} dispose={null}>
      <ScrollControls damping={0.1} pages={1}>
        <PivotControls
          enabled={true}
          lineWidth={3}
          depthTest={true}
          displayValues={false}
          rotation={[Math.PI / 2, 0, 0]}
          opacity={0.5}
          scale={0.1}>
          <PointCloudMesh />
          <PhysicalMesh />
          <BBoxMesh />
        </PivotControls>
      </ScrollControls>
    </group>
  )
}

useGLTF.preload(model)
